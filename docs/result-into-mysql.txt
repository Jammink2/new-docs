# Writing the Query Results into your MySQL Tables.

This article explains how to write job results to your existing MySQL instance.

## Prerequisites

  * Basic knowledge of Treasure Data, including [the toolbelt](http://toolbelt.treasure-data.com).
  * **A MySQL instance**. 
  * Treasure Data must have SELECT, INSERT, DELETE, CREATE, DROP and ALTER privileges.

## Architecture

A front-end application first posts data to Treasure Data. Treasure Data runs MapReduce jobs on the data, then writes the job results to your MySQL tables.

<center><img src="/images/result_rdbms.png" width="90%" /></center><br /><br />

NOTE: The results are written from the AWS US-East region. If you want better security control, please message support@treasure-data.com and ask for its account ID and security group name.

Shown above is a fairly common architecture. Here are a few examples.

#### Example 1: Ranking: What are the "Top N of X?"

Every social/mobile application calculates the "top N of X" (ex: top 5 movies watched today). Treasure Data already handles the raw data warehousing; the "write-to-MySQL" feature enables Treasure Data to find the "top N" data as well.

#### Example 2: Dashboard Application

If you're a data scientist, you need to keep track of a range of metrics every hour/day/month and make them accessible via visualizations. Using this "write-to-MySQL" feature, you can streamline the process and focus on your queries and your visualizations of the query results.

## Basic Usage

### For On-demand Jobs

For on-demand jobs, just add the `--result` option to the `td query` command. After the job is finished, the results are written into your table.

    :::sql
    $ td query --result 'mysql://user:password@host/database/table' \
      -w -d testdb \
      "SELECT v['code'], COUNT(1) FROM www_access GROUP BY v['code']"      

### For Scheduled Jobs

For scheduled jobs, just add the `--result` option when scheduling a job. Every time the job runs, the results are written into `mytbl`.

    :::term
    $ td result:create mydb mysql://user:password@host/database
    $ td sched:create hourly_count_example "0 * * * *" -d testdb "select count(*) from www_access" --result mydb:mytbl

## Four Modes to Modify Data (Append/Replace/Truncate/Update)

You can add or delete data in four ways.

    :::term
    mysql://user:password@host/database/table               # append
    mysql://user:password@host/database/table?mode=append   # append
    mysql://user:password@host/database/table?mode=replace  # replace
    mysql://user:password@host/database/table?mode=truncate # truncate
    mysql://user:password@host/database/table?mode=update   # update

All four modes are **atomic**.

**In the "host" section, you can specify the port as well.** Here is an example:

    :::term
    mysql://superadmin:superstrongpassword@data.science.com:27013/transaction/user_info

### APPEND

This is the default mode. The query results are appended to a table. If the table does not exist yet, a new table will be created.

### REPLACE

If the table already exists, the rows of the existing table are replaced with the query results. If the table does not exist yet, a new table will be created.

We achieve **atomicity** (so that a consumer of the table always has consistent data) by performing the following three steps in a **single transaction**.

1. Create a temporary table.
2. Write to the temporary table.
3. Replace the existing table with the temporary table using ALTER TABLE RENAME.

### TRUNCATE

The system first truncates the existing table, then inserts the query results. If the table does not exist yet, a new table will be created.

**Unlike REPLACE, TRUNCATE retains the indexes of your table.**

### UPDATE

This mode uses MySQL's "INSERT ... ON DUPLICATE KEY UPDATE" syntax (see [MySQL's documentation](http://dev.mysql.com/doc/refman/5.1/en/insert-on-duplicate.html)). In short, a row is inserted unless it would cause a duplicate value in the unique index or primary key, in which case an update is performed.
