# Supported UDFs (User Defined Functions)

This article lists all the UDFs supported on Treasure Data. Treasure Data supports two types of UDFs: (1) native UDFs supported by Hive and (2) Treasure Data specific functions whose names start with **TD_**.

## Hive native UDFs

All native UDFs on Hive can also be used on Treasure Data. The complete list of UDFs can be found on the [HiveQL Language Manual's UDF Page](https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF).

## TD_TIME_RANGE()

### Signature

    :::term
    boolean TD_TIME_RANGE(int/long unix_timestamp,
                          int/long/string start_time,
                          int/long/string end_time
                          [, string default_timezone = 'UTC'])

### Example

This example selects records with timestamps "2013-01-01 00:00:00 PDT" or later.

    :::sql
    SELECT ... WHERE TD_TIME_RANGE(time, "2013-01-01 PDT")
    SELECT ... WHERE TD_TIME_RANGE(time, "2013-01-01", NULL, "PDT")

NOTE: Notice that the time of day ("00:00:00") can be omitted, as shown above. Alternately, the time of day can be specified up to seconds. In general, the time string should be formatted as either "YYYY-MM-DD" or "YYYY-MM-DD hh:mm:ss", e.g., "2013-01-01" or "1999-01-01 07:00:00".

### Description

NOTE: We strongly recommend that you take advantage of time-based partitioning. Please refer to the <a href="performance-tuning">Performance Tuning</a> article for more information.

This UDF returns true if *unix_timestamp* is equal to or later than *start_time* and older than *end_time* (start_time <= time && time < end_time). If *end_time* is omitted or NULL, the UDF assumes it's infinite. If *start_time* is NULL, the UDF assumes it's 0.

*start_time* and *end_time* could be a string which represents a time (e.g. "2012-01-01 00:00:00 +0900") or a UNIX timestamp (e.g. 1325343600). If the format of *start_time* or *end_time* strings is invalid, the UDF returns NULL.

*default_timezone* is used to interpret the timezone of *start_time* or *end_time*. If *start_time* or *end_time* themselves specify a timezone (e.g. "2012-01-01 +0700"), then *default_timezone* is ignored. If *default_timezone* is not specified while *start_time* or *end_time* also does not specify a timezone, then the UDF uses 'UTC' as the timezone for *start_time* or *end_time*. A list of supported time zones can be found [here](https://gist.github.com/4533752).

## TD_TIME_ADD()

### Signature

    :::term
    long TD_TIME_ADD(int/long/string time,
                     string duration
                     [, string default_timezone = 'UTC'])

### Example

This example selects records with timestamps "2013-01-01 00:00:00 UTC" or later but older than "2013-01-02 00:00:00 UTC".

    :::sql
    SELECT ... WHERE TD_TIME_RANGE(time,
                                   "2013-01-01",
                                   TD_TIME_ADD("2013-01-01", "1d"))

### Description

This UDF returns a timestamp equal to *time* offset by *duration*. The UDF supports the following formats for the *duration*:

* "Nd": after N days (e.g. "1d", "2d", "30d")
* "-Nd": before N days (e.g. "-1d", "-2d", "-30d")
* "Nh": after N hours (e.g. "1h", "2h", "48h")
* "-Nh": before N hours (e.g. "-1h", "-2h", "-48h")
* "Nm": after N minutes (e.g. "1m", "2m", "90m")
* "-Nm": before N minutes (e.g. "-1m", "-2m", "-90m")
* "Ns": after N seconds (e.g. "1s", "2s", "90s")
* "-Ns": before N seconds (e.g. "-1s", "-2s", "-90s")

The formats above can be combined. For example, "1h30m" means "after 1 hour and 30 minutes".

*default_timezone* is used to interpret *time*. If *time* itself has timezone (e.g. "2012-01-01 +0700"), then *default_timezone* is ignored. If *default_timezone* is not specified while *time* also does not specify a timezone, then the UDF uses 'UTC' as the timezone for *time*. A list of supported time zones can be found [here](https://gist.github.com/4533752).

If the formats of the *time* or *duration* strings are invalid, the UDF returns NULL.

NOTE: "year" and "month" durations are NOT supported.

## TD_TIME_FORMAT()

### Signature

    :::term
    string TD_TIME_FORMAT(long unix_timestamp,
                          string format
                          [, string timezone = 'UTC'])

### Example

This example formats a UNIX timestamp into a date formatted string

    :::sql
    SELECT TD_TIME_FORMAT(time, "yyyy-MM-dd HH:mm:ss Z") ... FROM ...

### Description

This UDF converts a UNIX timestamp to a string with the specified format (see [here](http://java.sun.com/j2se/1.4.2/docs/api/java/text/SimpleDateFormat.html) for available formats). For example, "yyyy-MM-dd HH:mm:ss Z" converts 1325376000 to "2012-01-01 00:00:00 UTC". If no timezone is specified, the UDF uses UTC.

## TD_TIME_PARSE()

### Signature

    :::term
    long TD_TIME_PARSE(string time
                       [, string default_timezone = 'UTC'])

### Description

This UDF converts a time string into a UNIX timestamp.

*default_timezone* is used to interpret *time*. If *time* itself has timezone (e.g. "2012-01-01 +0700"), then *default_timezone* is ignored. If *default_timezone* is not specified while *time* also does not specify a timezone, then the UDF uses 'UTC' as the timezone for *time*. A list of supported time zones can be found [here](https://gist.github.com/4533752).

If the format of the *time* string is invalid, the UDF returns NULL.

## TD_SCHEDULED_TIME()

### Signature

    :::term
    long TD_SCHEDULED_TIME()

### Description

This UDF returns the exact time when the job was scheduled by the [scheduled query](schedule) feature. The returned value may differ from NOW() because the actual query start time may be delayed.

If the query is not a scheduled query, the UDF returns the time when the job was issued. You may use this UDF with TD_TIME_ADD for incremental aggregation.

## TD_LAST()

### Signature

    :::term
    TD_LAST(ret_col, cmp_col1, cmp_col2, ...)

### Description

This aggregate UDF finds the row with the largest value in the 'comparison column' (cmp_col1) and returns that row's 'retrieve column' (ret_col) value. Additional comparison columns (cmp_col2, cmp_col3, etc.) are used as tiebreakers when the preceding comparison column has more than one row with the largest value.

### Example

This example selects the URL of the most recent access log (the row with the largest time) for each user.

    :::sql
    SELECT user, TD_LAST(url, time) AS last_url FROM access_logs GROUP BY user

## TD_FIRST()

### Signature

    :::term
    TD_FIRST(ret_col, cmp_col1, cmp_col2, ...)

### Description

This aggregate UDF finds the row with the smallest value in the 'comparison column' (cmp_col1) and returns that row's 'retrieve column' (ret_col) value. Additional comparison columns (cmp_col2, cmp_col3, etc.) are used as tiebreakers when the preceding comparison column has more than one row with the smallest value.

### Example

This example selects the referer URL of the earliest access log (the row with the smallest time) for each page_id.

    :::sql
    SELECT page_id, TD_FIRST(referer, time) AS first_referer FROM access_logs GROUP BY page_id

## TD_X_RANK()

### Signature

    :::term
    long TD_X_RANK(keys)

### Example

You need to 'CLUSTER BY' or 'ORDER BY' within a sub query to use this feature. 'CLUSTER BY' is more scalable than 'ORDER BY' because it doesn't require total order across multiple nodes, thus allowing us to process the query in parallel.

    :::sql
    SELECT TD_X_RANK(c), c, u FROM
      (SELECT v['country'] AS c, v['user_id'] AS u
       FROM users CLUSTER BY c) t
    
    SELECT TD_X_RANK(c, lc1), c, lc1, u FROM
      (select v['country'] AS c, v['location1'] AS lc1, v['user_id'] AS u
       FROM users CLUSTER BY c, lc1) t

### Description

Returns the rank of each row within the partition of the result set. The rank of a row is one plus the number of ranks that come before the row.


## TD_SESSIONIZE()

### Signature

    :::term
    string TD_SESSIONIZE(time, timeout, )

### Description

This UDF takes three arguments (the time field specified in epoch time, a timeout window - period of this amount indicates that a new session has started, 
and field name to sessionize by) and returns a UUID for the session of the request.

### Example

Similiar to TD_X_RANK, you need to 'CLUSTER BY' or 'DISTRIBUTE BY' within a sub query. You also need to sort by the time field in asending order.

    :::sql
    SELECT TD_SESSIONIZE(time, 6000, host) as session_id, time, host, path
    FROM (
      SELECT time, v['host'] as host, v['path'] as path
      from web_logs
      distribute by host
      sort by time
    ) t

