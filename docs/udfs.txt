# Supported UDFs (User Defined Functions)

This article lists all the UDFs supported on Treasure Data. Treasure Data supports two types of UDFs: (1) native UDFs supported by Hive and (2) Treasure Data specific functions whose names start with **TD_**.

## Hive native UDFs

All native UDFs on Hive can also be used on Treasure Data. The list of UDFs are shown here.

* [HiveQL Language Manual | UDF](https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF)

## TD_TIME_RANGE()

### Signature

    :::term
    boolean TD_TIME_RANGE(int/long unix_timestamp,
                          int/long/string start_time,
                          int/long/string end_time
                          [, string default_timezone = 'UTC'])

### Example

Here's an example: select records newer or equal to "2013-01-01 00:00:00 PDT"

    :::sql
    SELECT ... WHERE TD_TIME_RANGE(time, "2013-01-01 PDT")
    SELECT ... WHERE TD_TIME_RANGE(time, "2013-01-01", NULL, "PDT")

NOTE: Notice how the time portion, "00:00:00", was omitted. Of course, you can specify up to seconds. In general, the time string format should be either "YYYY-MM-DD" or "YYYY-MM-DD hh:mm:ss", e.g., "2013-01-01" or "1999-01-01 07:10:23".

### Description

NOTE: We strongly recommend that you take advantage of time-based partitioning. Please check <a href="performance-tuning">Performance Tuning</a> guide.

This UDF returns true if *unix_timestamp* is newer or equals to *start_time* and older than *end_time* (start_time <= time && time < end_time). If *end_time* is omitted or NULL, the UDF assumes it's infinite. If *start_time* is NULL, the UDF assumes it's 0.

*start_time* and *end_time* could be a string which represents a time (e.g. "2012-01-01 00:00:00 +0900") or UNIX timestamp (e.g. 1325343600).
If the format of *start_time* or *end_time* strings is invalid, the UDF returns NULL.

*default_timezone* is used to recognize *start_time* or *end_time*. If *start_time* or *end_time* themselves have timezone specification (e.g. "2012-01-01 +0700"), *default_timezone* is ignored. If there're no timezone specifications, the UDF uses 'UTC'.

## TD_TIME_ADD()

### Signature

    :::term
    long TD_TIME_ADD(int/long/string time,
                     string duration
                     [, string default_timezone = 'UTC'])

### Example

Here's an example: select records newer or equal to "2013-01-01 00:00:00 UTC" and older than "2013-01-02 00:00:00 UTC".

    :::sql
    SELECT ... WHERE TD_TIME_RANGE(time,
                                   "2013-01-01",
                                   TD_TIME_ADD("2013-01-01", "1day"))

### Description

This UDF returns a timestamp after *duration* from *time*. The UDF supports following formats for the *duration*:

* "Nd": after N days (e.g. "1d", "2d", "30d")
* "-Nd": before N days (e.g. "-1d", "-2d", "-30d")
* "Nh": after N hours (e.g. "1h", "2h", "48h")
* "-Nh": before N hours (e.g. "-1h", "-2h", "-48h")
* "Nm": after N minutes (e.g. "1m", "2m", "90m")
* "-Nm": before N minutes (e.g. "-1m", "-2m", "-90m")
* "Ns": after N seconds (e.g. "1s", "2s", "90s")
* "-Ns": before N seconds (e.g. "-1s", "-2s", "-90s")

You can use combinations of the above formats. For example, "1h30m" means "after 1 hour and 30 minutes".

*default_timezone* is used to interpret *time*. If *time* itself has timezone (e.g. "2012-01-01 +0700"), that timezone overrides *default_timezone*. If no timezone is specified, the UDF uses UTC.

If the format of *time* or *duration* strings is invalid, the UDF returns NULL.

NOTE: "M" or "month" is NOT supported.

## TD_TIME_FORMAT()

### Signature

    :::term
    string TD_TIME_FORMAT(long unix_timestamp,
                          string format
                          [, string timezone = 'UTC'])

### Example

Here's an example: format timestamp to strings

    :::sql
    SELECT TD_TIME_FORMAT(time, "yyyy-MM-dd hh:mm:ss Z") ... FROM ...

### Description

This UDF converts a UNIX timestamp to a string with the given format (see [here](http://java.sun.com/j2se/1.4.2/docs/api/java/text/SimpleDateFormat.html) for available formats) For example, "yyyy-MM-dd HH:mm:ss Z" converts 1325376000 to "2012-01-01 00:00:00 UTC". If no timezone is specified, the UDF uses UTC.

## TD_TIME_PARSE()

    :::term
    long TD_TIME_PARSE(string time
                       [, string default_timezone = 'UTC'])

This UDF converts a time string into a UNIX timestamp.

*default_timezone* is used to interpret *time*. If *time* itself has timezone (e.g. "2012-01-01 +0700"), *default_timezone* is ignored. If no timezone is specified, the UDF uses 'UTC'.

If the format of *time* string is invalid, the UDF returns NULL.

## TD_SCHEDULED_TIME()

    :::term
    long TD_SCHEDULED_TIME()

This UDF returns the exact time when the job was scheduled by the [scheduled query] feature.
The returned value may differ from NOW() because the actual time queries run may be delayed.

If the query is not a scheduled query, the UDF returns the time when the job issued.
You may use this UDF with TD_TIME_ADD for incremental aggregation.

## TD_X_RANK()

### Signature

    :::term
    long TD_X_RANK(keys)

### Example

You need to 'CLUSTER BY' or 'ORDER BY' within a sub query to use this feature. 'CLUSTER BY' is more scalable than 'ORDER BY' because it doesn't requires total order across multiple nodes, thereby allowing us to process the query in parallel.

    :::sql
    SELECT TD_X_RANK(c), c, u FROM
      (SELECT v['country'] AS c, v['user_id'] AS u
       FROM users CLUSTER BY c) t
    
    SELECT TD_X_RANK(c, lc1), c, lc1, u FROM
      (select v['country'] AS c, v['location1'] AS lc1, v['user_id'] AS u
       FROM users CLUSTER BY c, lc1) t

### Description

Returns the rank of each row within the partition of the result set. The rank of a row is one plus the number of ranks that come before the row.