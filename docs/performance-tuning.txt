# Performance Tuning

## Prerequisites

  * Basic knowledge of Treasure Data, including [the toolbelt](http://toolbelt.treasure-data.com).
  * Basic knowledge of [td-agent](td-agent).
  * Basic knowledge of [the query language](hive).

## Leverage Time-based Partitioning

All imported data is automatically partitioned into hourly buckets, based on the **'time'** field within data records. **This means you can speed up your query significantly by specifying which time range to query because you avoid reading only the necessary data.**

### 1) WHERE time <=> Integer

By **setting conditions for the 'time' field within your WHERE clause**, the query parser can automatically recognize which partition should be processed. Please note that *if you specify the time with `float` instead of `int`, partitioning doesn't work.*

    :::sql
    [GOOD]: SELECT field1, field2, field3 FROM tbl WHERE time > 1349393020
    [GOOD]: SELECT field1, field2, field3 FROM tbl WHERE time > 1349393020 + 3600
    [GOOD]: SELECT field1, field2, field3 FROM tbl WHERE time > 1349393020 - 3600
    [BAD]:  SELECT field1, field2, field3 FROM tbl WHERE time > 1349393020.00

### 2) TD_TIME_RANGE

**An easier way to slice the data is using [TD_TIME_RANGE UDF](udfs#tdtimerange)**.

    :::sql
    SELECT ... WHERE TD_TIME_RANGE(time, "2013-01-01 PDT")
    SELECT ... WHERE TD_TIME_RANGE(time, "2013-01-01", NULL, "PDT")
    SELECT ... WHERE TD_TIME_RANGE(time, "2013-01-01",
                                   TD_TIME_ADD("2013-01-01", "1day", "PDT"))

## Set Custom Schema

As [the "Schema Management" article](schema) describes, all tables have two fields: 'v' and 'time'. In addition to that, you can set [custom schema](schema#setting-custom-schema) on the tables.

    :::term
    $ td schema:set testdb www_access action:string user:int
    $ td query -w -d testdb "SELECT user, COUNT(*) AS cnt
         FROM www_access
         WHERE action='login'
         GROUP BY user ORDER BY cnt DESC"

**By setting schema and querying with named columns instead of 'v'**, your query is executed with a more optimized execution path by using the schema information. Expecially, GROUP BY performance would improve significantly.
